// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkUserExistence = `-- name: CheckUserExistence :one
SELECT
    COUNT(users.user_id)
FROM users
WHERE users.clerk_id = $1
`

func (q *Queries) CheckUserExistence(ctx context.Context, clerkID string) (int64, error) {
	row := q.db.QueryRow(ctx, checkUserExistence, clerkID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteKey = `-- name: DeleteKey :exec
DELETE FROM keys
WHERE keys.key_id = $1
`

func (q *Queries) DeleteKey(ctx context.Context, keyID int64) error {
	_, err := q.db.Exec(ctx, deleteKey, keyID)
	return err
}

const deleteService = `-- name: DeleteService :exec
DELETE FROM services
WHERE services.sid = $1
`

func (q *Queries) DeleteService(ctx context.Context, sid int64) error {
	_, err := q.db.Exec(ctx, deleteService, sid)
	return err
}

const getAllProjects = `-- name: GetAllProjects :many
SELECT
    services.service_uuid,
    services.created_at,
    services.name,

    keys.key,
    keys.created_at,
    keys.updated_at,
    keys.cache,
    keys.storage,
    keys.expires_at,
    keys.id
FROM services
LEFT JOIN keys ON services.key_id = keys.key_id
WHERE services.user_id = $1
`

type GetAllProjectsRow struct {
	ServiceUuid pgtype.UUID
	CreatedAt   pgtype.Timestamptz
	Name        string
	Key         pgtype.Text
	CreatedAt_2 pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	Cache       pgtype.Bool
	Storage     pgtype.Bool
	ExpiresAt   pgtype.Int8
	ID          pgtype.Text
}

func (q *Queries) GetAllProjects(ctx context.Context, userID int64) ([]GetAllProjectsRow, error) {
	rows, err := q.db.Query(ctx, getAllProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllProjectsRow
	for rows.Next() {
		var i GetAllProjectsRow
		if err := rows.Scan(
			&i.ServiceUuid,
			&i.CreatedAt,
			&i.Name,
			&i.Key,
			&i.CreatedAt_2,
			&i.UpdatedAt,
			&i.Cache,
			&i.Storage,
			&i.ExpiresAt,
			&i.ID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllStorageData = `-- name: GetAllStorageData :many
SELECT
    storage.upload,
    storage.download,
    storage.created_at
FROM storage
WHERE storage.service_id = $1
`

type GetAllStorageDataRow struct {
	Upload    bool
	Download  bool
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) GetAllStorageData(ctx context.Context, serviceID int64) ([]GetAllStorageDataRow, error) {
	rows, err := q.db.Query(ctx, getAllStorageData, serviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllStorageDataRow
	for rows.Next() {
		var i GetAllStorageDataRow
		if err := rows.Scan(&i.Upload, &i.Download, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceCountForUserID = `-- name: GetServiceCountForUserID :one
SELECT
    COUNT(services.sid)
FROM services
WHERE services.user_id = $1
AND services.name = $2
`

type GetServiceCountForUserIDParams struct {
	UserID int64
	Name   string
}

func (q *Queries) GetServiceCountForUserID(ctx context.Context, arg GetServiceCountForUserIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, getServiceCountForUserID, arg.UserID, arg.Name)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getServiceData = `-- name: GetServiceData :one
SELECT
    services.sid,
    services.user_id,
    services.key_id
FROM services
WHERE services.name = $1
`

type GetServiceDataRow struct {
	Sid    int64
	UserID int64
	KeyID  int64
}

func (q *Queries) GetServiceData(ctx context.Context, name string) (GetServiceDataRow, error) {
	row := q.db.QueryRow(ctx, getServiceData, name)
	var i GetServiceDataRow
	err := row.Scan(&i.Sid, &i.UserID, &i.KeyID)
	return i, err
}

const getServiceIDFromAPIKey = `-- name: GetServiceIDFromAPIKey :one
SELECT
    services.sid
FROM services
LEFT JOIN keys ON services.key_id = keys.key_id
WHERE keys.key = $1
`

func (q *Queries) GetServiceIDFromAPIKey(ctx context.Context, key string) (int64, error) {
	row := q.db.QueryRow(ctx, getServiceIDFromAPIKey, key)
	var sid int64
	err := row.Scan(&sid)
	return sid, err
}

const getUserData = `-- name: GetUserData :one
SELECT 
    users.user_id,
    users.email,
    users.role,
    users.user_uiid,
    users.created_at,
    users.confirmed,
    users.deleted
FROM users
WHERE users.user_id = $1
`

type GetUserDataRow struct {
	UserID    int64
	Email     string
	Role      int64
	UserUiid  pgtype.UUID
	CreatedAt pgtype.Timestamptz
	Confirmed bool
	Deleted   bool
}

func (q *Queries) GetUserData(ctx context.Context, userID int64) (GetUserDataRow, error) {
	row := q.db.QueryRow(ctx, getUserData, userID)
	var i GetUserDataRow
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.Role,
		&i.UserUiid,
		&i.CreatedAt,
		&i.Confirmed,
		&i.Deleted,
	)
	return i, err
}

const getUserDataFromAPIKey = `-- name: GetUserDataFromAPIKey :one


SELECT
    keys.key_id,
    keys.created_at,
    keys.updated_at,
    keys.cache,
    keys.storage,

    users.user_id,
    users.role,
    users.user_uiid,
    users.confirmed
FROM keys
JOIN services ON keys.key_id = services.key_id
JOIN users ON users.user_id = services.user_id
WHERE keys.key = $1
`

type GetUserDataFromAPIKeyRow struct {
	KeyID     int64
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Cache     bool
	Storage   bool
	UserID    int64
	Role      int64
	UserUiid  pgtype.UUID
	Confirmed bool
}

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// CACHE QUERIES
func (q *Queries) GetUserDataFromAPIKey(ctx context.Context, key string) (GetUserDataFromAPIKeyRow, error) {
	row := q.db.QueryRow(ctx, getUserDataFromAPIKey, key)
	var i GetUserDataFromAPIKeyRow
	err := row.Scan(
		&i.KeyID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Cache,
		&i.Storage,
		&i.UserID,
		&i.Role,
		&i.UserUiid,
		&i.Confirmed,
	)
	return i, err
}

const getUserIDFromClerkID = `-- name: GetUserIDFromClerkID :one
SELECT 
    users.user_id
FROM users
WHERE users.clerk_id = $1
`

func (q *Queries) GetUserIDFromClerkID(ctx context.Context, clerkID string) (int64, error) {
	row := q.db.QueryRow(ctx, getUserIDFromClerkID, clerkID)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const insertKey = `-- name: InsertKey :one
INSERT INTO keys (key, cache, storage, expires_at, id)
VALUES ($1, $2, $3, $4, $5)
RETURNING key_id, created_at
`

type InsertKeyParams struct {
	Key       string
	Cache     bool
	Storage   bool
	ExpiresAt int64
	ID        string
}

type InsertKeyRow struct {
	KeyID     int64
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) InsertKey(ctx context.Context, arg InsertKeyParams) (InsertKeyRow, error) {
	row := q.db.QueryRow(ctx, insertKey,
		arg.Key,
		arg.Cache,
		arg.Storage,
		arg.ExpiresAt,
		arg.ID,
	)
	var i InsertKeyRow
	err := row.Scan(&i.KeyID, &i.CreatedAt)
	return i, err
}

const insertNewService = `-- name: InsertNewService :one
INSERT INTO services (user_id, key_id, name)
VALUES ($1, $2, $3)
RETURNING service_uuid
`

type InsertNewServiceParams struct {
	UserID int64
	KeyID  int64
	Name   string
}

func (q *Queries) InsertNewService(ctx context.Context, arg InsertNewServiceParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertNewService, arg.UserID, arg.KeyID, arg.Name)
	var service_uuid pgtype.UUID
	err := row.Scan(&service_uuid)
	return service_uuid, err
}

const insertStorageData = `-- name: InsertStorageData :exec





INSERT INTO storage (service_id, upload, download, created_at) 
VALUES ($1, $2, $3, $4)
`

type InsertStorageDataParams struct {
	ServiceID int64
	Upload    bool
	Download  bool
	CreatedAt pgtype.Timestamptz
}

// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
// Data Analytics
// -- name: GetLatestStorage :one
// SELECT
//
//	storage.last_up,
//	storage.up_count,
//	storage.last_down,
//	storage.down_count
//
// FROM storage
// WHERE storage.service_id = $1
// ORDER BY storage.last_up DESC
// LIMIT 1;
func (q *Queries) InsertStorageData(ctx context.Context, arg InsertStorageDataParams) error {
	_, err := q.db.Exec(ctx, insertStorageData,
		arg.ServiceID,
		arg.Upload,
		arg.Download,
		arg.CreatedAt,
	)
	return err
}

const signupUser = `-- name: SignupUser :exec
INSERT INTO users (email, role, clerk_id)
VALUES ($1, $2, $3)
`

type SignupUserParams struct {
	Email   string
	Role    int64
	ClerkID string
}

func (q *Queries) SignupUser(ctx context.Context, arg SignupUserParams) error {
	_, err := q.db.Exec(ctx, signupUser, arg.Email, arg.Role, arg.ClerkID)
	return err
}

const updateKeyServicesConfirmation = `-- name: UpdateKeyServicesConfirmation :one
UPDATE keys 
SET 
    cache = $2,
    storage = $3
WHERE key_id = $1
RETURNING cache, storage
`

type UpdateKeyServicesConfirmationParams struct {
	KeyID   int64
	Cache   bool
	Storage bool
}

type UpdateKeyServicesConfirmationRow struct {
	Cache   bool
	Storage bool
}

func (q *Queries) UpdateKeyServicesConfirmation(ctx context.Context, arg UpdateKeyServicesConfirmationParams) (UpdateKeyServicesConfirmationRow, error) {
	row := q.db.QueryRow(ctx, updateKeyServicesConfirmation, arg.KeyID, arg.Cache, arg.Storage)
	var i UpdateKeyServicesConfirmationRow
	err := row.Scan(&i.Cache, &i.Storage)
	return i, err
}
